# Lv9+.3. 优化

在之前的章节中, 你实现的编译器只负责把 SysY 编译到 RISC-V 汇编, 而不会进行任何形式的优化. 实际上, 在业界的各类编译器实现中, 优化相关的部分所占的比重, 要远远大于其他的部分. 毕竟, 生成高性能的程序, 才是编译器的目标.

编译优化并不是一件多么高深莫测的事情. 有很多简单的优化, 你只要稍做了解, 便可以把它们添加到你的编译器中.

## 优化的分类

编译器中涉及的优化, 大体可以分为两类:

* **机器无关优化:** 和目标机器 (目标指令系统) 无关的, 在 IR 层面就能进行的优化. 比如对程序结构的变换, 或者对 IR 中冗余操作的消除.
* **机器相关优化:** 和目标机器 (目标指令系统) 相关的, 在目标代码上进行的优化. 比如软流水 ([software pipelining](https://en.wikipedia.org/wiki/Software_pipelining)), 或者一些目标代码层面的窥孔优化.

接下来我们为这两类优化分别举一个简单的例子.

### 死代码消除

死代码消除 ([dead code elimination](https://en.wikipedia.org/wiki/Dead_code_elimination), DCE), 顾名思义, 就是删除程序里根本用不到的代码, 也就是所谓的 “死代码”. 比如对于如下的 SysY 程序:

```c
int main() {
  int a = 1;
  int b = 2;
  a = a + 3;
  b = b + a;
  return 0;
}
```

你的编译器可能会生成对应的 Koopa IR:

```koopa
fun @main(): i32 {
%entry:
  @a = alloc i32
  store 1, @a
  @b = alloc i32
  store 2, @b
  %0 = load @a
  %1 = add %0, 3
  store %0, @a
  %2 = load @b
  %3 = load @a
  %4 = add %2, %3
  store %4, @b
  ret 0
}
```

你可以发现, SysY 程序里声明了两个变量, 哼哧哼哧一顿算, 最后只是返回了一个 0, 之前的计算结果一个都没用到. 那我们为什么不干脆把这些没用的代码都删掉呢:

```koopa
fun @main(): i32 {
%entry:
  ret 0
}
```

这段程序和之前那段完全等价, 但看起来显然清爽了许多, 效率也更高. 那我们要怎么才能实现 DCE 呢? DCE 本质上是把没用的代码删掉, 那我们必须先知道, 哪些代码是没用的, 或者换句话说: 知道哪些代码是有用的.

从例子出发, 我们知道, 这个例子中只有那句 `return` 是有用的, 因为它控制了 `main` 函数的返回值, 使得我们能在外部观测到这个结果. 而 `return` 语句没有用到之前任何语句的结果, 这些语句就变成了死代码, 因为无论它们存在与否, 我们在外部都观测不到程序执行结果的任何变化.

所以道理就很简单了: 任何会产生副作用的代码都是有用的代码, 任何不产生副作用, 并且执行结果没被有用的代码用到的代码, 都是死代码. 比如:

*  `ret`, `br`, `jump` 都会产生副作用, 即控制流转移. 我们实现的 DCE 暂不关心控制流, 所以所有和控制流相关的代码都可以视作有副作用.
* 如果 `call` 指令调用的函数存在副作用, 那 `call` 指令也会产生副作用. 一个有副作用的函数, 可能执行了 I/O 操作, 可能向指针指向的内存写入了数据 (比如写入了传入的数组参数), 可能写了全局变量, 也可能调用了其他有副作用的函数.
* 如果 `store` 指令写了指针参数或者全局变量, 那它也是有副作用的.

?> 关于写指针操作的判断, 其实比上面的描述复杂的多. 当然, 为了避免过于复杂的讨论, 你可以把假设定得更保守一些, 比如假定所有的 `call`/`store` 都是有副作用的. 但这样显然会导致 DCE 的效果大打折扣.
<br><br>
在某些编程语言里, 某个变量的指针/引用可以被到处传来传去, 也可以被任意修改, 导致这些指针/引用又指向了其他的变量. 要想分析某个指针是否指向了可能会导致副作用的那些变量, 你就必须做一些比较复杂的分析. 我们称这类分析为指针分析 ([pointer analysis](https://en.wikipedia.org/wiki/Pointer_analysis)). 这又是编译/程序分析领域的一大深坑.

然后, 你可以从这些已经确定不会被删掉的指令出发, 遍历它们用到的其他指令, 把这些指令也标记为 “有用”. 接着在依次标记和这些指令相关的其他指令……直到再也标记不出新指令为止. 此时, 函数中剩下的指令, 就都可以被删掉了.

?> 如果只是单独实现 DCE, 优化效果还是比较有限的, 毕竟一般我们不会刻意去写一些能被编译器一眼鉴定为死代码的代码.
<br><br>
DCE 存在的价值是为其他优化擦屁股: 很多情况下, 某些优化跑完之后, 会产生一些新的死代码. 比如你实现了常量传播优化, 传播完了之后原先的变量被替换成了一个常量, 所有计算过程都被求出来了——这部分代码就变成了死代码. 如果在此之后再跑一遍 DCE, 整个 IR 就会变得清爽很多.

### 消除冗余 load

?> **TODO:** ~DLC 未解锁.~ 待补充.

## 优化的组织

?> **TODO:** ~DLC 未解锁.~ 待补充.

## 更多的优化

?> **TODO:** ~DLC 未解锁.~ 待补充.

## SSA 形式

?> **TODO:** ~DLC 未解锁.~ 待补充.

## SSA 形式上的优化

?> **TODO:** ~DLC 未解锁.~ 待补充.
